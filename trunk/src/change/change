#! /bin/bash

# Copyright 1999-2002 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License v2
# Author: Dan Armak <danarmak@gentoo.org>
# $Header: /space/gentoo/cvsroot/gentoolkit/src/change/change,v 1.2 2002/08/11 13:32:12 karltk Exp $

eval `grep PORTDIR= /etc/make.globals`
eval `grep PORTDIR= /etc/make.conf`
[ -z "$PORTDIR" ] && PORTDIR="/usr/portage"

# register temp files (we delete them in the end)
TMPMESSAGE=`tempfile -p change` || cleanup 1
TMPHEADER=`tempfile -p change` || cleanup 1
TMPENTRY=`tempfile -p change` || cleanup 1
TMPOLDLOG=`tempfile -p change` || cleanup 1
TMPCHANGELOG=`tempfile -p change` || cleanup 1

# get user info from config file - $AUTHORNAME and $AUTHOREMAIL
init() {
    . ~/.gentoo/gentool-env || return 1
}

print_about() {

    echo "change v 0.2.4 - A Gentoo ChangeLog editor."
    echo "Author Dan Armak <danarmak@gentoo.org>"
}

print_usage() {

    echo "Usage:
change <package list> [-shv] [-m|--message msg] [-f|--message-file file] 
                             [-a|--authorname name] [-l|--authormail mail] 
                             [-n|--new-version ver] [-o|--output dest]

<package list>: List of packages whose changelogs are to be  edited. All 
changelogs edited in one run will be added the same log message.

Acceptable formats:	     Example:
category/package	     kde-base/kdebase
path to package dir	     kdebase || ../../kdebase
path to changelog file	     portage/kde-base/kdebase/ChangeLog

Note that you must use -g for changelog files outside $PORTDIR.

-m, --message \"msg\"        Use log message \"msg\", do not open editor.
-f, --message-file <file>  Use contents of <file> as log message, do not open
                           editor.
-a, --authorname \"name\"    Use \"name\" (e.g. Dan Armak) in log.
-l, --authormail \"email\"   Use \"email\" (e.g. danarmak@gentoo.org) in log.
-n, --new-version \"ver\"    Add a line about a new version number \"ver\" to 
                           the log.
-g, --generate             Create a new changelog file if one does not exist.
                           This option must come before the list of affected 
                           changelog files. Incidentally, this option also 
                           enables you to work with a changelog file outside 
                           $PORTDIR. 
                           You must use it every time you edit such a file.
                           However, change won't be able to figure out the
                           category and package names of your changelog file
                           and those parts will be missing. (FIXME!)
-o, --output \"file\"        Save new changelog in file \"file\".
                           Default is the the same file we're changing (i.e. 
                           no backup).
-s, --stdout               Print new changelog to stdout (disables saving to 
                           file). This suppresses the usual info messages.
-c, --changed-files        List of changed files (goes into entry header). 
                           Default is to simply say \"ChangeLog :\". Multiple 
                           -c options can be given.
-h, --help                 Print this usage information.
-v, --version              Print a short about line and the version number and 
                           exit.
    
See also the mandatory config file ~/.gentoo/gentool-env (the gentool-env man
page contains a template).
"

}

# parse command line parameters
# this function should be called before all others (e.g. before init())
# or else it might stomp on some settings
parse_params() {

    # at least one parameter required - changelog to process
    if [ -z "$1" ]; then
	echo "At least one parameter is required."
	print_about
	print_usage
	cleanup 1
    fi

    while [ -n "$1" ]; do

	# note: with parameters that come in two pieces (i.e. -m foo)
	# we identify the first one, grab the second one from $2 and 
	# shift an extra time
	case "$1" in

	    # optional log message, if defined then we won't launch $EDITOR
	    # comes in explicit string and file reference variations
	    -m | --message)
		MESSAGE="$2"
		shift
		;;
	    -f | --message-file)
		cp $2 $TMPMESSAGE
		shift
		;;
	    
	    # general settings (usually set in .change)
	    -a | --authorname)
		AUTHORNAME="$2"
		shift
		;;
	    -l | --authormail)
		AUTHOREMAIL="$2"
		shift
		;;
		
	    # add a line about a new version (starting with *) to the changelog
	    # to add the line but no changelog info, call with -n -m ""
	    -n | --new-version)
		NEWVERSION="$2"
		shift
		;;
		
	    # create a new changelog file
	    -g | --generate)
		GENERATE=true
		;;
		
	    # output redirection. default (if $OUTPUT isn't set) is to change the
	    # specified changelog file.
	    # illegal if more than one changelog file/package is specified.
	    -o | --output)
		OUTPUT="$2"
		shift
		;;
	    # redirect output to stdout - can be combined with -o
	    -s | --stdout)
		STDOUT="true"
		OUTPUT="/dev/null"
		;;
	    
	    # list of files changed (second part inclosed in quotes!)
	    -c | --changed-files)
		CHANGED="$CHANGED $2"
		shift
		;;
	    
	    # request for version/usage information etc
	    -h | --help)
		print_about
		print_usage
		cleanup 0
		;;
	    -v | --version)
		print_about
		cleanup 0
		;;
	    
	    # everything else we couldn't identify. most of it is packages/files to work on.
	    *)
		for x in "$MYPORTDIR/$1/ChangeLog" "$PORTDIR/$1/ChangeLog" "$PWD/$1/ChangeLog" "$PWD/$1"; do
		    if [ -f "$x" ]; then
			FILES="$FILES $x"
			shift # because by calling continue we skip the shift at the end of the case block
			continue 2 # next while iteration
		    fi
		done
		# if we haveb't detected a changelog file, maybe we need to create one
		if [ -n "$GENERATE" ]; then
		    for x in "$PWD/$1" "$1" "$MYPORTDIR/$1" "$PORTDIR/$1"; do
			if [ -d "$x" ]; then
			    touch $x/ChangeLog
			    FILES="$FILES $x/ChangeLog"
			    shift # because by calling continue we skip the shift at the end of the case block
			    continue 2 # next while iteration
			fi
		    done
		fi
		
		echo "!!! Error: unrecognized option: $1"
		echo
		print_usage
		cleanup 1
	    
		;;
	
	esac
	
	shift
    done
    
    if [ -z "$FILES" ]; then
	echo "No changelog path or package name passed, mandatory parameter missing."
	echo
	print_usage
	cleanup 1
    fi

}

# get the log message
get_msg() {

    if [ -n "`cat $TMPMESSAGE`" ]; then
	echo "Using message-on-file."
    elif [ -n "$MESSAGE" ]; then
	echo "$MESSAGE" > $TMPMESSAGE
    else # [ -z "$MESSAGE" ]
    
	echo > $TMPMESSAGE
    	echo "Please enter changelog. You can leave this line, it will be automatically removed." >> $TMPMESSAGE
	$EDITOR $TMPMESSAGE
	cp $TMPMESSAGE ${TMPMESSAGE}2
	sed -e '/Please enter changelog. You can leave this line, it will be automatically removed./ D' \
	    ${TMPMESSAGE}2 > $TMPMESSAGE
	rm ${TMPMESSAGE}2
    
    fi

    # break up into 80-character columns (actually 78 chars because we'll
    # add two spaces to every line)
    cp $TMPMESSAGE ${TMPMESSAGE}2
    fmt -s -w 78 ${TMPMESSAGE}2 > $TMPMESSAGE
    rm ${TMPMESSAGE}2

    # add two spaces to the beginning of every line of the message.
    # do this separately from the sed in the else section above
    # because it should be executed for the if and elif sections too.
    cp $TMPMESSAGE ${TMPMESSAGE}2
    sed -e 's:^:  :g' ${TMPMESSAGE}2 > $TMPMESSAGE
    rm ${TMPMESSAGE}2
    
}

# get list of files and wrap it in the following manner:
# 1 item on the first list and upto 80 chars on every other.
# also adds 2 spaces to the beginning of every line but the first.
wrap_list() {

    echo -n $1
    shift
    
    while [ -n "$1" ]; do
	if [ -n "$LIST" ]; then
	    LIST="$LIST, $1"
	else
	    echo ,
	    LIST="$1"
	fi
	shift
    done
    LIST="$LIST :"
    
    echo $LIST | fmt -s -w 78 | sed -e 's:^:  :g' -

}

# do the actual work on te changelog file passed as $1
process() {
    # figure out category and package names
    name=${1//${PORTDIR}}
    name=${name//${MYPORTDIR}}
    name=${name//\/ChangeLog}
    
    OLDIFS="$IFS"
    IFS="/"
    for x in $name; do
	if [ -z "$CATEGORY" ]; then
	    CATEGORY="$x"
	else
	    PACKAGE="$x"
	fi
    done
    IFS="$OLDIFS"

    # create header
    echo \
"# ChangeLog for $CATEGORY/$PACKAGE
# Copyright 2002 Gentoo Technologies, Inc.; Distributed under the GPL v2
# \$Header: \$
" > $TMPHEADER

    # create entry line
    if [ -n "$NEWVERSION" ]; then
	echo "*$PACKAGE-$NEWVERSION (`date '+%d %b %Y'`)" > $TMPENTRY
	echo >> $TMPENTRY
    fi
    
    echo -n "  `date "+%d %b %Y"`; ${AUTHORNAME} <${AUTHOREMAIL}> " >> $TMPENTRY
    [ -z "$CHANGED" ] && CHANGED="ChangeLog "
    wrap_list $CHANGED >> $TMPENTRY
    
    echo >> $TMPENTRY

    # get the original changelog, minus the old header
    sed -e '/^# ChangeLog for/ D
	    /^# Copyright 2002 Gentoo Technologies/ D
	    /^# \$Header:/ D' $1 > $TMPOLDLOG

    # join everything together
    cat $TMPHEADER $TMPENTRY $TMPMESSAGE $TMPOLDLOG > $TMPCHANGELOG
    
    # various output options
    if [ -n "$OUTPUT" ]; then
	cp $TMPCHANGELOG $OUTPUT
	[ -z "$STDOUT" ] && echo "New changelog saved in $OUTPUT."
    else
	cp $TMPCHANGELOG $1
	[ -z "$STDOUT" ] && echo "Original changelog $1 replaced."
    fi

    if [ -n "$STDOUT" ]; then
	cat $TMPCHANGELOG
    fi

}

# pass exit code to this function
cleanup() {

    rm -f $TMPMESSAGE $TMPHEADER $TMPENTRY $TMPCHANGELOG $TMPOLDLOG
    
    exit $1
    
}

parse_params "${@}"

init

get_msg

for x in $FILES; do
    process $x
done

cleanup 0

