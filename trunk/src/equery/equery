#!/usr/bin/python
#
# Copyright 2003-2004 Karl Trygve Kalleberg
# Copyright 2003-2004 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License v2
#
# $Header$
# Author: Karl Trygve Kalleberg <karltk@gentoo.org>

__author__ = "Karl Trygve Kalleberg"
__email__ = "karltk@gentoo.org"
__version__ = "0.1.2"
__productname__ = "equery"
__description__ = "Gentoo Package Query Tool"

import os
import re
import sys
import time
import string
import types

# portage (output module) and gentoolkit need special path modifications
sys.path.insert(0, "/usr/lib/portage/pym")
sys.path.insert(0, "/usr/lib/gentoolkit/pym")

import gentoolkit
import portage

import gentoolkit.pprinter as pp
from gentoolkit.pprinter import print_info, print_error, print_warn

# Auxiliary functions

def fileAsStr(name, fdesc, showType=0, showMD5=0, showTimestamp=0):
    """
    Return file in fdesc as a filename
    @param name: 
    @param fdesc:
    @param showType:
    @param showMD5:
    @param showTimestamp:
    @rtype: string
    """
    type = ""; fname = ""; stamp = ""; md5sum = ""

    if fdesc[0] == 'obj':
        type = "file"
        fname = name
        stamp = timestampAsStr(int(fdesc[1]))
        md5sum = fdesc[2]
    elif fdesc[0] == "dir":
        type = "dir"
        fname = pp.path(name)
    elif fdesc[0] == "sym":
        type = "symlink"
        stamp = timestampAsStr(int(fdesc[1].replace(")","")))
        tgt = fdesc[2].split()[0]
        fname = pp.path_symlink(name + " -> " + tgt)
    else:
        raise "Unknown type: " + fdesc[0]

    s = ""
    if showType:
        s += "%6s " % type
    s += fname
    if showTimestamp:
        s += " " + stamp + " "
    if showMD5:
        s += " " + md5sum + " "
    return s

def timestampAsStr(timestamp):
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(timestamp))

    
class Command:
    """
    Abstract root class for all equery commands
    """
    def __init__(self):
        pass
    def shortHelp(self):
        """Return a help formatted to fit a single line, approx 70 characters.
        Must be overridden in the subclass."""
        return " - not implemented yet"
    def longHelp(self):
        """Return full, multiline, color-formatted help.
        Must be overridden in the subclass."""
        return "help for syntax and options"
    def perform(self, args):
        """Stub code for performing the command.
        Must be overridden in the subclass"""
        pass
    def parseArgs(self, args):
        """Stub code for parsing command line arguments for this command.
        Must be overridden in the subclass."""
        pass

    
class CmdListFiles(Command):
    """List files owned by a particular package"""
    def __init__(self):
        self.default_options = {
            "showType": 0,
            "showTimestamp": 0,
            "showMD5": 0
            }

    def parseArgs(self,args):
        query = ""
        need_help = 0
        opts = self.default_options
        for x in args:
            if x in ["-h", "--help"]:
                need_help = 1
            elif x in ["--md5sum"]:
                opts["showMD5"] = 1
            elif x in ["--timestamp"]:
                opts["showTimestamp"] = 1
            elif x in ["--type"]:
                opts["showType"] = 1
            else:
                query = x

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)
    
    def perform(self, args):

        (query, opts) = self.parseArgs(args)

        if not Config["piping"]:
            print_info(3, "[ Searching for packages matching " + pp.pkgquery(query) + "... ]")
            
        pkgs = gentoolkit.find_installed_packages(query, True)
        for x in pkgs:
            print x.get_cpv()
            if not x.is_installed():
                continue
        
            print_info(1, pp.section("* ") + "Contents of " + pp.cpv(x.get_cpv()) + ":")

            cnt = x.get_contents()

            filenames = cnt.keys()
            filenames.sort()
            
            for name in filenames:
                print_info(0, fileAsStr(name,
                                    cnt[name],
                                    showType=opts["showType"],
                                    showTimestamp=opts["showTimestamp"],
                                    showMD5=opts["showMD5"]))
        
    def longHelp(self):
        return "List files owned by a particular package\n" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("files") + pp.localoption(" <local-opts> ") + pp.pkgquery("<cat/>packagename<-version>") + "\n" + \
               "\n" + \
               "Note: category and version parts are optional. \n" + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
               "  " + pp.localoption("--timestamp") + "  - append timestamp\n" + \
               "  " + pp.localoption("--md5sum") + "     - append md5sum\n" + \
               "  " + pp.localoption("--type") + "       - prepend file type"               
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - list files owned by " + pp.pkgquery("pkgspec")

    
class CmdListBelongs(Command):
    """List all packages owning a particular file"""
    def __init__(self):
        self.default_opts = {
            "category": "*",
            "fullRegex": 0,
            "earlyOut": 0
            }

    def parseArgs(self, args):

        query = []
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-c", "--category"]:
                opts["category"] = args[i+1]
                skip = 1
            elif x in ["-e", "--earlyout"]:
                opts["earlyOut"] = 1
            elif x in ["-f", "--full-regex"]:
                opts["fullRegex"] = 1
            else:
                query.append(x)

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)
                
    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        # Act intelligently on the query
        try:
            q = string.join(query, "|") 
            if opts["fullRegex"]: 
                rx = re.compile(q)
            elif len(q) and q[0] == "/":
                rx = re.compile("^" + q + "$")
            else:
                rx = re.compile("/" + q + "$")
        except:
            die(2, "The query '" + pp.regexpquery(q) + "' does not appear to be a valid regular expression")

        # Pick out only selected categories
        cat = opts["category"]
        filter_fn = None
        if cat != "*":
            filter_fn = lambda x: x.find(cat+"/")==0

        if not Config["piping"]:
            print_info(3, "[ Searching for file(s) " + pp.regexpquery(string.join(query,",")) + " in " + pp.cpv(cat) + "... ]")
            
        matches = gentoolkit.find_all_installed_packages(filter_fn)

        found = 0

        def dumpToPipe(pkg):
            cnt = pkg.get_contents()
            if not cnt: return
            for file in cnt.keys():
                if rx.search(file):
                    print pkg.get_cpv()
                    return

        class DummyExp:
            pass
            
        def dumpToScreen(pkg):
            cnt = pkg.get_contents()
            if not cnt: return
            for file in cnt.keys():
                if rx.search(file):
                    s = pp.cpv(pkg.get_cpv())
                    s += " (" + pp.path(fileAsStr(file, cnt[file])) + ")"
                    print_info(0, s)
                    if opts["earlyOut"]:
                        raise DummyExp

        try: 
            if Config["piping"]:
                map(dumpToPipe, matches)
            else:
                map(dumpToScreen, matches)
        except DummyExp:
            pass
            
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.path("files...") + " - list all packages owning " + pp.path("files...")
    def longHelp(self):
        return "List all packages owning a particular set of files" + \
               "\n" + \
               "\n" + \
               pp.emph("Note: ") + "Normally, only one package will own a file. If multiple packages own the same file, it usually consitutes a problem, and should be reported.\n" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("belongs") + pp.localoption(" <local-opts> ") + pp.path("filename") + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
                    "  " + pp.localoption("-c, --category cat") + " - only search in category " + \
                        pp.pkgquery("cat") + "\n" + \
                    "  " + pp.localoption("-f, --full-regex") + "   - supplied query is a regex\n" + \
                    "  " + pp.localoption("-e, --earlyout") + "     - stop when first match is found\n"

class CmdDisplayUSEs(Command):
    """Advanced report of a package's USE flags"""
    def __init__(self):
        self.default_opts = {
            "installedOnly" : True
            }
    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-a", "--all"]:
                opts["installedOnly"] = False
            else:
                query = x

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)

    def perform(self, args):

        (query, opts) = self.parseArgs(args)
        
        matches = gentoolkit.find_packages(query, True)

        if not matches:
            die(3, "No matching packages found for \"" + pp.pkgquery(query) + "\"")


        useflags = gentoolkit.settings["USE"].split()    
        usedesc = {}
        uselocaldesc = {}

        # Load global USE flag descriptions
        try:
            fd = open(gentoolkit.settings["PORTDIR"]+"/profiles/use.desc")
            usedesc = {}
            for line in fd.readlines():
                if line[0] == "#":
                    continue
                fields = line.split(" - ")
                if len(fields) == 2:
                    usedesc[fields[0].strip()] = fields[1].strip()
        except IOError:
            print_warn(5, "Could not load USE flag descriptions from " + ppath(gentoolkit.settings["PORTDIR"] + "/profiles/use.desc"))

        # Load local USE flag descriptions
        try:
            fd = open(gentoolkit.settings["PORTDIR"]+"/profiles/use.local.desc")
            for line in fd.readlines():
                if line[0] == "#":
                    continue
                fields = line.split(" - ")
                if len(fields) == 2:
                    catpkguse = re.search("([a-z]+-[a-z]+/.*):(.*)", fields[0])
                    if catpkguse:
                        if not uselocaldesc.has_key(catpkguse.group(1).strip()):
                            uselocaldesc[catpkguse.group(1).strip()] = {catpkguse.group(2).strip() : fields[1].strip()}
                        else:
                            uselocaldesc[catpkguse.group(1).strip()][catpkguse.group(2).strip()] = fields[1].strip()
        except IOError:
                print_warn(5, "Could not load USE flag descriptions from " + path(gentoolkit.settings["PORTDIR"] + "/profiles/use.desc"))

        if not Config["piping"]: 
            print_info(3, "[ Colour Code : " + pp.useflagon("set") + " " + pp.useflagoff("unset") + " ]")
            print_info(3, "[ Legend    : Left column  (U) - USE flags from make.conf              ]")
            print_info(3, "[           : Right column (I) - USE flags packages was installed with ]")

        # Iterate through matches, printing a report for each package
        printed_matches = 0
        for p in matches:
            if not p.is_installed() and opts["installedOnly"]:
                continue
    
            bestver = p.get_cpv()
            iuse = p.get_env_var("IUSE")

            if iuse:
                usevar = iuse.split()
            else:
                usevar = []

            inuse = []
            if p.is_installed():
                used = p.get_use_flags().split()
            else:
                # cosmetic issue here as noninstalled packages don't have "used" flags
                used = useflags

            # store (inuse, inused, flag, desc)
            output = []

            for u in usevar:
                inuse = 0
                inused = 0
                try:
                    desc = usedesc[u]
                except KeyError:
                    try:
                        desc = uselocaldesc[p.get_category() + "/" + p.get_name()][u]
                    except KeyError:
                        desc = ""

                if u in p.get_settings("USE"):
                    inuse = 1
                if u in used:
                    inused = 1

                output.append((inuse, inused, u, desc))

            # pretty print
            if output:
                if not Config["piping"]:
                    print_info(0, "[ Found these USE variables for " + pp.cpv(bestver) + " ]")
                    print_info(3, pp.emph(" U I"))
                maxflag_len = 0
                for inuse, inused, u, desc in output:
                    if len(u) > maxflag_len:
                        maxflag_len = len(u)

                for in_makeconf, in_installed, flag, desc in output:
                    markers = ["-","+"]
                    colour = [pp.useflagoff, pp.useflagon]
                    if Config["piping"]:
                        print_info(0, markers[in_makeconf] + flag)
                    else:
                        if in_makeconf != in_installed:
                            print_info(0, pp.emph(" %s %s" % (markers[in_makeconf], markers[in_installed])), False)
                        else:
                            print_info(0, " %s %s" % (markers[in_makeconf], markers[in_installed]), False)
    
                        print_info(0, " " + colour[in_makeconf](flag.ljust(maxflag_len)), False)

                        # print description
                        if desc:
                            print_info(0, " : " + desc)
                        else:
                            print_info(0, " : <unknown>")
                printed_matches += 1
            else:
                if not Config["piping"]:
                    print_info(1, "[ No USE flags found for " + pp.cppv(p.get_cpv()) + "]")

        if Config["verbosityLevel"] >= 2:
            if printed_matches == 0:
                s = ""
                if opts["installedOnly"]:
                    s = "installed "
                die(3, "No " + s + "packages found for " + pp.pkgquery(query))
                
                    
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - display USE flags for " + pp.pkgquery("pkgspec")
    def longHelp(self):
        return "Display USE flags for a given package\n" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("uses") + pp.localoption(" <local-opts> ") + pp.pkgquery("pkgspec") + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
               "  " + pp.localoption("-a, --all") + "     - include non-installed packages\n"


class CmdDisplayDepGraph(Command):
    """Display tree graph of dependencies for a query"""

    def __init__(self):
        self.default_opts = {
            "displayUSEFlags": 1,
            "fancyFormatting": 1
            }

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-U","--no-useflags"]:
                opts["displayUSEFlags"] = 0
            elif x in ["-l","--linear"]:
                opts["fancyFormatting"] = 0
            else:
                query = x

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)

    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        if not Config["piping"]:
            print_info(3, "[ Searching for packages matching " + pp.pkgquery(query) + "... ]")

        matches = gentoolkit.find_packages(query, True)

        for pkg in matches:
            if not pkg.is_installed():
                continue
            if Config["piping"]:
                print_info(0, pkg.get_cpv() + ":")
            else:
                print_info(3, pp.section("* ") + "dependency graph for " + pp.cpv(pkg.get_cpv()))

            stats = { "maxdepth": 0, "packages": 0 }
            self._graph(pkg, opts, stats)
            print_info(0, "[ " + pp.cpv(pkg.get_cpv()) + " stats: packages (" + pp.number(str(stats["packages"])) + \
                "), max depth (" + pp.number(str(stats["maxdepth"])) + ") ]")
        
    def _graph(self, pkg, opts, stats, level=0, pkgtbl=[], suffix=""):
    
        stats["packages"] += 1
        stats["maxdepth"] = max(stats["maxdepth"], level)
        
        cpv = pkg.get_cpv()

        pfx = ""
        if opts["fancyFormatting"]:
            pfx = level * " " + "`-- " 
        print_info(0, pfx + cpv + suffix)
        
        pkgtbl.append(cpv)
        
        for x in pkg.get_runtime_deps():
            suffix = ""
            cpv = x[2]
            pkg = gentoolkit.find_best_match(x[0] + cpv)
            if not pkg:
                continue
            if pkg.get_cpv() in pkgtbl:
                continue
            if cpv.find("virtual") == 0:
                suffix += " (" + pp.cpv(cpv) + ")"
                if len(x[1]) and opts["displayUSEFlags"]:
                    suffix += " [ " + pp.useflagon(string.join(x[1])) + " ]"
            pkgtbl = self._graph(pkg, opts, stats, level+1, pkgtbl, suffix)
        return pkgtbl

    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - display a dependency tree for " + pp.pkgquery("pkgspec")
    def longHelp(self):
        return "Display a dependency tree for a given package\n" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("depgraph") + pp.localoption(" <local-opts> ") + pp.pkgquery("pkgspec") + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
               "  " + pp.localoption("-U, --no-useflags") + " - do not show USE flags\n" + \
               "  " + pp.localoption("-l, --linear") + "      - do not use fancy formatting"

class CmdDisplaySize(Command):
    """Display disk size consumed by a package"""
    def __init__(self):
        self.default_opts = {
            "reportSizeInBytes": 0
            }

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-b","--bytes"]:
                opts["reportSizeInBytes"] = 1
            else:
                query = x

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)
                
    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        if not Config["piping"]:
            print_info(3, "[ Searching for packages matching " + pp.pkgquery(query) + "... ]")

        matches = gentoolkit.find_packages(query, True)

        for pkg in matches:
            if not pkg.is_installed():
                continue

            (size, files, uncounted) = pkg.size()

            if Config["piping"]:
                print_info(0, pkg.get_cpv() + ": total(" + str(files) + "), inaccessible(" + str(uncounted) + \
                    "), size(" + str(size) + ")")
            else:
                print_info(0, pp.section("* ") + "size of " + pp.cpv(pkg.get_cpv()) + " ]")
                print_info(0, string.rjust(" Total files : ",25) + pp.number(str(files)))
    
                if uncounted:
                    print_info(0, string.rjust(" Inaccessible files : ",25) + pp.number(str(uncounted)))
    
                sz = "%.2f KiB" % (size/1024.0)                
                if opts["reportSizeInBytes"]:
                    sz = number(str(size)) + " bytes"
                
                print_info(0, string.rjust("Total size  : ",25) + pp.number(sz))

                    
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - print size of files contained in package " + pp.pkgquery("pkgspec")
    def longHelp(self):
        return "Print size total size of files contained in a given package" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("size") + pp.localoption(" <local-opts> ") + pp.pkgquery("pkgspec") + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
               "  " + pp.localoption("-b, --bytes") + " - report size in bytes\n"

class CmdDisplayChanges(Command):
    """Display changes for pkgQuery"""
    pass

class CheckException:
    def __init__(self, s):
        self.s = s
    
class CmdCheckIntegrity(Command):
    """Check timestamps and md5sums for files owned by pkgspec"""
    def __init__(self):
        self.default_opts = {
            "showSummary" : 1,
            "showGoodFiles" : 0,
            "showBadFiles" : 1,
            "checkTimestamp" : 1,
            "checkMD5sum": 1
            }

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):
            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            else:
                query = x

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)

    def checkMD5sum(self, file):
        return 1
    
    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        matches = gentoolkit.find_packages(query, True)

        for pkg in matches:
            if not pkg.is_installed():
                continue
            if Config["piping"]:
                print_info(0, pkg.get_cpv() + ":")
            else:
                print_info(1, "[ Checking " + pp.cpv(pkg.get_cpv()) + " ]")
                
            files = pkg.get_contents()
            checked_files = 0
            good_files = 0
            for file in files.keys():
                type = files[file][0]
                try:
                    st = os.lstat(file)
                    if type == "dir":
                        if not os.path.isdir(file):
                            raise CheckException(file + " exists, but is not a directory")
                    elif type == "obj":
                        mtime = files[file][1]
                        if opts["checkTimestamp"]:
                            if st.st_mtime != int(mtime):
                                raise CheckException(white(file) + (" has wrong mtime (is %d, should be %s)" % (st.st_mtime, mtime)))
                        if opts["checkMD5sum"]:
                            if not self.checkMD5sum(file):
                                raise CheckException(file + " has incorrect md5sum")
                    elif type == "sym":
                        # FIXME: nastry strippery; portage should have this fixed!
                        t = files[file][2]
                        target = os.path.normpath(t.strip())
                        if not os.path.islink(file):
                            raise CheckException(file + " exists, but is not a symlink")
                        tgt = os.readlink(file)
                        if tgt != target:
                            raise CheckException(file + " does not point to " + target)
                            
                    else:
                        pp.print_error(file)
                        pp.print_error(files[file])
                        pp.print_error(type)
                        raise "Unknown type"
                    good_files += 1
                except CheckException, (e):
                    print_error(e.s)
                except OSError:
                    print_error(path(file) + " does not exist")
                checked_files += 1
            print_info(0, pp.section(" * ") + pp.number(str(good_files)) + " out of " +  pp.number(str(checked_files)) + " files good")
                    
    def shortHelp(self):
        return pp.pkgquery("pkgspec") + " - check MD5sums and timestamps of " + pp.pkgquery("pkgspec") + "'s files"
    def longHelp(self):
        return "Check package's files against recorded MD5 sums and timestamps" + \
                "\n" + \
                "Syntax:\n" + \
                "  " + pp.command("size") + pp.pkgquery(" pkgspec")

class CmdDisplayStatistics(Command):
    """Display statistics about installed and uninstalled packages"""
    pass

class CmdWhich(Command):
    """Display the filename of the ebuild for a given package
       that would be used by Portage with the current configuration."""
    def __init__(self):
        self.default_opts = {}

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            else:
                query = x

        if need_help or query == "":
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)
                
    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        matches = gentoolkit.find_packages(query, True)
        matches = gentoolkit.sort_package_list(matches)

        if matches:
            print_info(0, os.path.normpath(matches[-1].get_ebuild_path()))
        else:
            print_error("No masked or unmasked packages found for " + pkgquery(query))
                    
    def shortHelp(self):
        return pp.pkgquery("pkgspec") + " - print full path to ebuild for package " + pp.pkgquery("pkgspec")
    def longHelp(self):
        return "Print full path to ebuild for a given package" + \
            "\n" + \
            "Syntax:\n" + \
            "  " + pp.command("size ") + pp.pkgquery("pkgspec")

class CmdListGLSAs(Command):
    """List outstanding GLSAs."""
    pass

class CmdListDepends(Command):
    """List all packages directly or indirectly depending on pkgQuery"""
    def __init__(self):
        self.default_opts = {
            "onlyDirect": 1,
            "onlyInstalled": 0
            }

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
         
        for i in xrange(len(args)):
            if skip:
                skip -= 1
                continue
            x = args[i]
             
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-d", "--direct"]:
                opts["onlyDirect"] = 1
            elif x in ["-D", "--indirect"]:
                opts["onlyDirect"] = 0
            elif x in ["-i", "--only-installed"]:
                opts["onlyInstalled"] = 1
            else:
                query = x
     
        if need_help or query == "":
            print self.longHelp()
            sys.exit(-1)
        return (query, opts)
 
    def perform(self, args):
        def subdeps(cpv, spacing):
            "Find subdeps of a package"
            cpvs=gentoolkit.split_package_name(cpv) 
 
            catname = cpvs[0]+"/"+cpvs[1]
            if depscache.has_key(catname):
                isdep = 0
                for dep in depscache[catname]:
                    pkg = dep[0]
                    x = dep[1]
                    if string.find(x[2],"/") != -1 and \
                           portage.match_from_list(x[0]+x[2], [cpv]):
                        if x[1]:
                            print spacing+pkg.get_cpv(),
                            if Config["verbosityLevel"] >= 4:
                                print " (" +string.join(x[1],"&")+ " ? " + x[0]+x[2] + ")"
                            else:
                                print
                        else:
                            print spacing+pkg.get_cpv(),
                            if Config["verbosityLevel"] >= 4:
                                print " (" + x[0]+x[2] + ")"
                            else:
                                print
                        isdep = 1
                    if isdep:
                        subdeps(pkg.get_cpv(), spacing+" ")
  
 
        (query, opts) = self.parseArgs(args)
 
        if not Config["piping"]:
            print_info(3, "[ Searching for packages matching " + pp.pkgquery(query) + "... ]")
 
        isdepend = gentoolkit.split_package_name(query)
 
        
        if opts["onlyInstalled"]:
            packages = gentoolkit.find_all_installed_packages()
        else:
            packages = gentoolkit.find_all_packages()
 
        if not opts["onlyDirect"]:
            print_info(4, "Caching indirect dependencies...")
            depscache = {"":[]}
            for pkg in packages:
                
                print_info(1, pp.section("* ") + "Dependencies for " + pp.cpv(pkg.get_cpv()) + ":")

                try:
                    deps = pkg.get_runtime_deps()
                except KeyError, e:
                    # If the ebuild is not found... 
                    continue
                for x in deps:
                    cpvs=gentoolkit.split_package_name(x[2]) 
                    #print cpvs
                    catname = cpvs[0]+"/"+cpvs[1]
                    if depscache.has_key(catname):
                        depscache[catname].append((pkg,x))
                    else:
                        depscache[catname] = [(pkg,x)]
            print "done"
 
        for pkg in packages:
            try:
                deps = pkg.get_runtime_deps()
            except KeyError, e:
                # If the ebuild is not found... 
                continue
            isdep = 0
            for x in deps:
                cpvs=gentoolkit.split_package_name(x[2])
                cat_match=0
                ver_match=0
                name_match=0
                if not isdepend[0] or \
                    string.find(cpvs[0], isdepend[0]) == 0:
                    cat_match=1
                if not isdepend[2] or \
                    ( string.find(cpvs[2],isdepend[2]) == 0 and \
                      (isdepend[3] or \
                       isdepend[3] == "r0" or \
                       string. find(cpvs[3],isdepend[3]) == 0)):
                      ver_match=1
                if string.find(cpvs[1], isdepend[1]) == 0:
                     name_match=1
                if cat_match and ver_match and name_match:
                     if not isdep:
                         if x[1]:
                             print pkg.get_cpv(),
                             if Config["verbosityLevel"] >= 4:
                                   print " (" +string.join(x[1],"&")+ " ? " + x[0]+x[2] + ")"
                             else:
                                 print
                         else:
                             print pkg.get_cpv(),
                             if Config["verbosityLevel"] >= 4:
                                 print " (" + x[0]+x[2] + ")"
                             else:
                                 print
                         isdep = 1
                     elif Config["verbosityLevel"] >= 4:
                         if x[1]:
                             print " "*len(pkg.get_cpv()) + " (" +string.join(x[1],"&")+ " ? " + x[0]+x[2] + ")"
                         else:
                             print " "*len(pkg.get_cpv()) + " (" + x[0]+x[2] + ")"    
            if isdep and not opts["onlyDirect"] :
                 subdeps(pkg.get_cpv(), " ")
 
 
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - list all direct dependencies matching " + pp.pkgquery("pkgspec")
     
    def longHelp(self):
         return "List all direct dependencies matching a query pattern" + \
                "\n" + \
                "Syntax:\n" + \
                "  " + pp.command("depends") + pp.localoption(" <local-opts> ") + pp.pkgquery("pkgspec") + \
                "\n" + \
                pp.localoption("<local-opts>") + " is either of: \n" + \
                "  " + pp.localoption("-d, --direct") + "             - search direct dependencies only (default)\n" + \
                "  " + pp.localoption("-D, --indirect") + "           - search indirect dependencies (VERY slow)\n" + \
                "  " + pp.localoption("-i, --only-installed") + "     - search installed in installed packages only\n"


class CmdListPackages(Command):
    """List packages satisfying pkgQuery"""
    def __init__(self):
        self.default_opts = {
            "category": "*",
            "includeInstalled": 1,
            "includePortTree": 0,
            "includeOverlayTree": 0,
            "includeMasked": 1,
            "regex": 0
            }

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-i", "--installed"]:
                opts["includeInstalled"] = 1
            elif x in ["-I", "--exclude-installed"]:
                opts["includeInstalled"] = 0
            elif x in ["-p", "--portage-tree"]:
                opts["includePortTree"] = 1
            elif x in ["-o", "--overlay-tree"]:
                opts["includeOverlayTree"] = 1
            elif x in ["-m", "--exclude-masked"]:
                opts["includeMasked"] = 0
            else:
                query = x

        if need_help:
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)
                
    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        rev = ".*"
        name = ".*"
        ver = ".*"
        cat = ".*"
        
        if query != "":
            (cat, name, ver, rev) = gentoolkit.split_package_name(query)

            if rev == "r0": rev = ".*"
            if name == "": name = ".*"
            if ver == "": ver = ".*"
            if cat == "": cat = ".*"
            
        package_finder = None

        if opts["includeInstalled"] and (opts["includePortTree"] or opts["includeOverlayTree"]):
            package_finder = gentoolkit.find_all_packages
        elif opts["includeInstalled"]:
            package_finder = gentoolkit.find_all_installed_packages
        elif opts["includePortTree"] or opts["includeOverlayTree"]:
            package_finder = gentoolkit.find_all_uninstalled_packages

        if not package_finder:
            die(2, "You must specify one of ") + yellow("-i") + red(", ") + yellow("-p") + red(" or ") + yellow("-o")

        filter_fn = None

        if query != "":
            rx = re.compile(cat + "/" + name)
            filter_fn = lambda x: rx.search(x)
        else:
            filter_fn = lambda x: True
            
        if Config["verbosityLevel"] >= 3:
            scat = "'" + cat + "'"
            if cat == ".*":
                scat = "all categories"
            sname = "package '" + name + "'"
            if name == ".*":
                sname = "all packages"
            if not Config["piping"]:
                print_info(1, "Searching for " + pp.cpv(sname) + " in " + pp.cpv(scat) + " among:")
                if opts["includeInstalled"]:
                    print_info(1, pp.section(" *") + " installed packages")
                if opts["includePortTree"]:
                    print_info(1, pp.section(" *") + " Portage tree (" + pp.path(gentoolkit.settings["PORTDIR"]) + ")")
                if opts["includeOverlayTree"]:
                    print_info(1, pp.section(" *") + " overlay tree (" + pp.path(gentoolkit.settings["PORTDIR_OVERLAY"]) + ")")
        
        matches = package_finder(filter_fn)

        rx = re.compile(cat + "/" + name + "-" + ver + "(-" + rev + ")?")
        pfxmodes = [ "---", "I--", "-P-", "--O" ]
        maskmodes = [ "  ", " ~", " -", "M ", "M~", "M-" ]
        for pkg in matches:
            status = 0
            if pkg.is_installed():
                status = 1
            elif pkg.is_overlay():
                status = 3
            else:
                status = 2

            # Determining mask status
            pkgmask = 0
            if pkg.is_masked():
                pkgmask = pkgmask + 3
            keywords = pkg.get_env_var("KEYWORDS").split()
            if "~" + gentoolkit.settings["ARCH"] in keywords:
                pkgmask = pkgmask + 1
            elif "-*" in keywords or "-" + gentoolkit.settings["ARCH"] in keywords:
                pkgmask = pkgmask + 2

            # Determining SLOT value
            slot = pkg.get_env_var("SLOT")

            if (status == 1 and opts["includeInstalled"]) or \
               (status == 2 and opts["includePortTree"]) or \
               (status == 3 and opts["includeOverlayTree"]):
                if rx.search(pkg.get_cpv()):
                    if Config["piping"]:
                        print_info(0, pkg.get_cpv())
                    else:
                        print_info(0, "[" + pp.installedflag(pfxmodes[status]) + "] [" + pp.maskflag(maskmodes[pkgmask]) + "] " + pp.cpv(pkg.get_cpv()) + " (" + pp.slot(slot) + ")")
                    
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - list all packages matching " + pp.pkgquery("pkgspec")
    def longHelp(self):
        return "List all packages matching a query pattern" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("list") + pp.localoption(" <local-opts> ") + pp.pkgquery("pkgspec") + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
               "  " + pp.localoption("-i, --installed") + "         - search installed packages (default)\n" + \
               "  " + pp.localoption("-I, --exclude-installed") + " - do not search installed packages\n" + \
               "  " + pp.localoption("-p, --portage-tree") + "      - also search in portage tree (" + gentoolkit.settings["PORTDIR"] + ")\n" + \
               "  " + pp.localoption("-o, --overlay-tree") + "      - also search in overlay tree (" + gentoolkit.settings["PORTDIR_OVERLAY"] + ")\n"

class CmdFindUSEs(Command):
    """Find all packages with a particular USE flag."""
    def __init__(self):
        self.default_opts = {
            "category": "*",
            "includeInstalled": 1,
            "includePortTree": 0,
            "includeOverlayTree": 0,
            "includeMasked": 1,
            "regex": 0
            }

    def parseArgs(self, args):

        query = ""
        need_help = 0
        opts = self.default_opts
        skip = 0
        
        for i in xrange(len(args)):

            if skip:
                skip -= 1
                continue
            x = args[i]
            
            if x in ["-h","--help"]:
                need_help = 1
                break
            elif x in ["-i", "--installed"]:
                opts["includeInstalled"] = 1
            elif x in ["-I", "--exclude-installed"]:
                opts["includeInstalled"] = 0
            elif x in ["-p", "--portage-tree"]:
                opts["includePortTree"] = 1
            elif x in ["-o", "--overlay-tree"]:
                opts["includeOverlayTree"] = 1
            elif x in ["-m", "--exclude-masked"]:
                opts["includeMasked"] = 0
            else:
                query = x

        if need_help:
            print_info(0, self.longHelp())
            sys.exit(-1)
            
        return (query, opts)
                
    def perform(self, args):
        (query, opts) = self.parseArgs(args)

        rev = ".*"
        name = ".*"
        ver = ".*"
        cat = ".*"
        
        package_finder = None

        if opts["includeInstalled"] and (opts["includePortTree"] or opts["includeOverlayTree"]):
            package_finder = gentoolkit.find_all_packages
        elif opts["includeInstalled"]:
            package_finder = gentoolkit.find_all_installed_packages
        elif opts["includePortTree"] or opts["includeOverlayTree"]:
            package_finder = gentoolkit.find_all_uninstalled_packages

        if not package_finder:
            die(2,"You must specify one of " + yellow("-i") + red(", ") + yellow("-p") + red(" or ") + yellow("-o"))

        filter_fn = lambda x: True
            
        if Config["verbosityLevel"] >= 3:
            scat = "'" + cat + "'"
            if cat == ".*":
                scat = "all categories"
            if not Config["piping"]:
                print_info(2, "Searching for USE flag " + pp.useflag(query)  + " in " + pp.cpv(scat) + " among:")
                if opts["includeInstalled"]:
                    print_info(1, pp.section(" *") + " installed packages")
                if opts["includePortTree"]:
                    print_info(1, pp.section(" *") + " Portage tree (" + pp.path(gentoolkit.settings["PORTDIR"]) + ")")
                if opts["includeOverlayTree"]:
                    print_info(1, pp.section(" *") + " overlay tree (" + pp.path(gentoolkit.settings["PORTDIR_OVERLAY"]) + ")")
        
        matches = package_finder(filter_fn)

        rx = re.compile(cat + "/" + name + "-" + ver + "(-" + rev + ")?")
        pfxmodes = [ "---", "I--", "-P-", "--O" ]
        maskmodes = [ "  ", " ~", " -", "M ", "M~", "M-" ]
        for pkg in matches:
            status = 0
            if pkg.is_installed():
                status = 1
            elif pkg.is_overlay():
                status = 3
            else:
                status = 2

            # Drop all packages without the USE flag
            useflags = []
            if status == 1:
                useflags = pkg.get_use_flags()
            else:
                useflags = pkg.get_env_var("IUSE")
            
            if query not in useflags:
                continue 
                
            # Determining mask status
            pkgmask = 0
            if pkg.is_masked():
                pkgmask = pkgmask + 3
            keywords = pkg.get_env_var("KEYWORDS").split()
            if "~"+gentoolkit.settings["ARCH"] in keywords:
                pkgmask = pkgmask + 1
            elif "-*" in keywords or "-"+gentoolkit.settings["ARCH"] in keywords:
                pkgmask = pkgmask + 2

            # Determining SLOT value
            slot = pkg.get_env_var("SLOT")

            if (status == 1 and opts["includeInstalled"]) or \
               (status == 2 and opts["includePortTree"]) or \
               (status == 3 and opts["includeOverlayTree"]):
                if Config["piping"]:
                    print_info(0, pkg.get_cpv())
                else:
                    print_info(0, "[" + pp.installedflag(pfxmodes[status]) + "] [" + pp.maskflag(maskmodes[pkgmask]) + "] " + pp.cpv(pkg.get_cpv()) + " (" + pp.slot(slot) + ")")
                    
    def shortHelp(self):
        return pp.localoption("<local-opts> ") + pp.pkgquery("pkgspec") + " - list all packages with " + pp.pkgquery("useflag")
    def longHelp(self):
        return "List all packages with a particular USE flag" + \
               "\n" + \
               "Syntax:\n" + \
               "  " + pp.command("list") + pp.localoption(" <local-opts> ") + pp.pkgquery("useflag") + \
               "\n" + \
               pp.localoption("<local-opts>") + " is either of: \n" + \
               "  " + pp.localoption("-i, --installed") + "         - search installed packages (default)\n" + \
               "  " + pp.localoption("-I, --exclude-installed") + " - do not search installed packages\n" + \
               "  " + pp.localoption("-p, --portage-tree") + "      - also search in portage tree (" + gentoolkit.settings["PORTDIR"] + ")\n" + \
               "  " + pp.localoption("-o, --overlay-tree") + "      - also search in overlay tree (" + gentoolkit.settings["PORTDIR_OVERLAY"] + ")\n"

#
# Command line tokens to commands mapping
#

Known_commands = {
    "list" : CmdListPackages(),
    "files" : CmdListFiles(),
    "belongs" : CmdListBelongs(),
    "depends" : CmdListDepends(),
    "hasuses" : CmdFindUSEs(),
    "uses" : CmdDisplayUSEs(),
    "depgraph" : CmdDisplayDepGraph(),
    "changes" : CmdDisplayChanges(),
    "size" : CmdDisplaySize(),
    "check" : CmdCheckIntegrity(),
    "stats" : CmdDisplayStatistics(),
    "glsa" : CmdListGLSAs(),
    "which": CmdWhich()
    }

# Short command line tokens

Short_commands = {
    "a" : "glsa",
    "b" : "belongs",
    "c" : "changes",
    "d" : "depends",
    "f" : "files",
    "g" : "depgraph",
    "h" : "hasuses",
    "k" : "check",
    "l" : "list",
    "s" : "size",
    "t" : "stats",
    "u" : "uses",
    "w" : "which"
}

from gentoolkit import Config

Config = {
    # Query will include packages installed on the system
    "installedPackages":  1,
    # Query will include packages available for installation
    "uninstalledPackages": 0,
    # Query will include overlay packages (iff uninstalledPackages==1)
    "overlayPackages": 1,
    # Query will include masked packages (iff uninstalledPackages==1)
    "maskedPackages": 0,
    # Query will only consider packages in the following categories, empty means all.
    "categoryFilter": [],
    # Enable color output (-1 = use Portage setting, 0 = force off, 1 = force on)
    "color": -1,
    # Level of detail on the output
    "verbosityLevel": 3,
    # Query will display info for multiple SLOTed versions
    "considerDuplicates": 1,
    # Are we writing to a pipe?
    "piping": 0
}
    
def printVersion():
    """Print the version of this tool to the console."""
    print_info(0, __productname__ + "(" + __version__ + ") - " + \
          __description__)
    print_info(0, "Author(s): " + __author__)

def buildReverseMap(m):
    r = {}
    for x in m.keys():
        r[m[x]] = x
    return r
    
def printUsage():
    """Print full usage information for this tool to the console."""
    
    short_cmds = buildReverseMap(Short_commands);
    
    print_info(0, pp.emph("Usage: ") + pp.productname(__productname__) + pp.globaloption(" <global-opts> ") + pp.command("command") + pp.localoption(" <local-opts>"))
    print_info(0, "where " + pp.globaloption("<global-opts>") + " is one of")
    print_info(0, pp.globaloption(" -q, --quiet") + "   - minimal output")
    print_info(0, pp.globaloption(" -C, --nocolor") + " - turn off colours")
    print_info(0, pp.globaloption(" -h, --help") + "    - this help screen")
    print_info(0, pp.globaloption(" -V, --version") + " - display version info")
    
    print_info(0, "where " + pp.command("command") + "(" + pp.command("short") + ") is one of")
    keys = Known_commands.keys()
    keys.sort()
    for x in keys:
        print_info(0, " " + pp.command(x) + "(" + pp.command(short_cmds[x]) + ") " + \
            Known_commands[x].shortHelp())
    print
    
def configure():
    """Set up default configuration.
    """
    
    # Guess colour output
    if (Config["color"] == -1 and \
        ((not sys.stdout.isatty()) or \
         (gentoolkit.settings["NOCOLOR"] in ["yes","true"]))) \
         or \
         Config["color"] == 0:
            pp.output.nocolor()

    # Guess piping output
    if not sys.stdout.isatty():
        Config["piping"] = True
    else:
        Config["piping"] = False
        
    
def parseArgs(args):
    """Parse tool-specific arguments. 
    
    Arguments are on the form equery <tool-specific> [command] <command-specific>
    
    This function will only parse the <tool-specific> bit.
    """
    command = None
    local_opts = []
    showhelp = 0

    def expand(x):
        if x in Short_commands.keys():
            return Short_commands[x]
        return x
        
    for i in xrange(len(args)):
        x = args[i]
        if 0:
            pass
        elif x in ["-h", "--help"]:
            showhelp = True
        elif x in ["-V", "--version"]:
            printVersion()
            sys.exit(0)
        elif x in ["-C", "--nocolor"]:
            Config["color"] = False
        elif x in ["-N", "--no-pipe"]:
            Config["piping"] = False
        elif x in ["-q","--quiet"]:
            Config["verbosityLevel"] = 0
        elif expand(x) in Known_commands.keys():
            command = Known_commands[expand(x)]
            local_opts = args[i+1:]
            if showhelp:
                local_opts.append("--help")
            break
        
    if not command and showhelp:
        printUsage()
        sys.exit(0)

    return (command, local_opts)
   
if __name__ == "__main__":
    configure()
    (cmd, local_opts) = parseArgs(sys.argv[1:])
    if cmd:
        try:
            cmd.perform(local_opts)
        except KeyError, e:
            if e and type(e[0]) == types.ListType and \
                    string.find(e[0], "Specific key requires operator") == 0:
                print_error("Invalid syntax: missing operator")
                print_error("If you want only specific versions please use one of")
                print_error("the following operators as prefix for the package name:")
                print_error("   >  >=  =  <=  <")
                print_error("Example to only match gcc versions greater or equal 3.2:")
                print_error("   >=sys-devel/gcc-3.2")
                
            else:
                print_error("Internal portage error, terminating")
                if len(e[0]):
                    print_error(e)
            sys.exit(2)
        except ValueError, e:
            if e and type(e[0]) == types.ListType:
                print_error("Ambiguous package name " + white("\"" + local_opts[0] + "\""))
                print_error("Please use one of the following long names:")
                for p in e[0]:
                    print_error("    " + p)
            else:
                print_error("Internal portage error, terminating")
                if len(e[0]):
                    print_error(e[0])
            sys.exit(2)
        except KeyboardInterrupt:
            print_info(0, "Interrupted by user, aborting.")
    else:
        print_error("No command or unknown command given")
        printUsage()
  
